############################################
# CONFIG CONSTANTS (CHANGE ONLY HERE)
############################################

# PROCESS & FILE LIMITS
# WORKER_CONNECTIONS = 65536
# WORKER_RLIMIT_NOFILE = 65535

# LISTEN & UPSTREAM PORTS
# LISTEN_PORT = 3000
# UPSTREAM_API_PORT = 3001
# UPSTREAM_WEBHOOK_PORT = 3003
# UPSTREAM_GRPC_PORT = 50051

# TIMEOUTS (clients & proxies)
# CLIENT_BODY_TIMEOUT = 30s
# CLIENT_HEADER_TIMEOUT = 30s
# SEND_TIMEOUT = 30s
# PROXY_CONNECT_TIMEOUT = 60s
# PROXY_CONNECT_TIMEOUT_API = 60s
# PROXY_CONNECT_TIMEOUT_AUTH = 30s
# PROXY_CONNECT_TIMEOUT_GRPC = 120s
# PROXY_SEND_TIMEOUT_API = 60s
# PROXY_SEND_TIMEOUT_AUTH = 30s
# PROXY_SEND_TIMEOUT_GRPC = 300s
# PROXY_SEND_TIMEOUT_SOCKETIO = 300s
# PROXY_SEND_TIMEOUT_WEBHOOK = 60s
# PROXY_READ_TIMEOUT_API = 60s
# PROXY_READ_TIMEOUT_AUTH = 30s
# PROXY_READ_TIMEOUT_GRPC = 300s
# PROXY_READ_TIMEOUT_SOCKETIO = 300s
# PROXY_READ_TIMEOUT_WEBHOOK = 60s

# HTTP/2 & CONNECTIONS
# HTTP2_CHUNK_SIZE = 8k
# HTTP2_MAX_CONCURRENT_STREAMS = 512
# HTTP2_RECV_BUFFER_SIZE = 128k
# LARGE_CLIENT_HEADER_BUFFERS_COUNT = 4
# LARGE_CLIENT_HEADER_BUFFERS_SIZE = 16k
# KEEPALIVE_REQUESTS = 10000
# KEEPALIVE_TIMEOUT = 120s
# LIMIT_CONN_ZONE_SIZE = 100m

# UPSTREAM KEEPALIVE & ZONES
# UPSTREAM_KEEPALIVE_MAX = 512
# UPSTREAM_KEEPALIVE_MED = 256
# UPSTREAM_KEEPALIVE_MIN = 128
# UPSTREAM_ZONE_SIZE = 256k

# RATE LIMITS & CONNECTION CONTROLS
# LIMIT_CONN_API_PER_IP = 500
# LIMIT_CONN_AUTH = 100
# LIMIT_CONN_PER_IP = 500
# LIMIT_CONN_SOCKETIO_PER_IP = 2000
# LIMIT_CONN_WEBHOOK_PER_IP = 2000
# LIMIT_REQ_API_RATE = 200r/m
# LIMIT_REQ_AUTH_RATE = 10r/m
# LIMIT_REQ_AUTH_BURST = 200
# LIMIT_REQ_FLOOD_BURST = 2000
# LIMIT_REQ_FLOOD_RATE = 200r/s
# LIMIT_REQ_SOCKETIO_BURST = 5000
# LIMIT_REQ_SOCKETIO_RATE = 500r/m
# LIMIT_REQ_WEBHOOK_BURST = 500
# LIMIT_REQ_WEBHOOK_RATE = 200r/m

# GZIP, BUFFERS & CLIENT SIZE
# GZIP_COMP_LEVEL = 6
# GZIP_MIN_LENGTH = 1024
# PROXY_BUFFER_SIZE = 4k
# PROXY_BUFFERS_COUNT = 8
# PROXY_BUFFERS_SIZE = 4k
# PROXY_BUSY_BUFFERS_SIZE = 8k
# CLIENT_BODY_BUFFER_SIZE = 512k
# CLIENT_HEADER_BUFFER_SIZE = 2k
# MAX_CLIENT_BODY_SIZE = 10M

# LOGGING & CACHES
# ACCESS_LOG_BUFFER = 64k
# OPEN_FILE_CACHE_MAX = 100000
# OPEN_FILE_CACHE_INACTIVE = 120s
# OPEN_FILE_CACHE_MIN_USES = 2

############################################

events {
    worker_connections 65536;    # WORKER_CONNECTIONS => Increased: Max simultaneous connections per worker process
    use epoll;                  # Event notification method (Linux) for scalable I/O multiplexing
    multi_accept on;            # Accept multiple new connections per event loop iteration
}

user node;                     # Run worker processes as 'node' user (least-privilege principle)
pid /tmp/nginx.pid;            # Master process PID file location
worker_processes auto;         # Auto-detect optimal worker count based on CPU cores
worker_rlimit_nofile 65535;    # WORKER_RLIMIT_NOFILE => Increased: Max file descriptors per worker (sockets + files)

http {
    include /etc/nginx/mime.types;          # Load standard MIME type mappings
    default_type application/octet-stream;  # Fallback MIME type for unknown files

    # ============================================
    # HTTP/2 CONFIGURATION (Modern syntax)
    # ============================================
    http2 on;  # Enable HTTP/2 globally for all HTTPS listeners
    
    # HTTP/2 specific settings
    large_client_header_buffers 4 16k;  # LARGE_CLIENT_HEADER_BUFFERS_COUNT & SIZE => Max 4 buffers of 16k each for large headers (cookies, auth tokens, long URIs)
    http2_max_concurrent_streams 512;   # HTTP2_MAX_CONCURRENT_STREAMS => Increased: Max concurrent streams per HTTP/2 connection
    client_header_timeout 30s;          # CLIENT_HEADER_TIMEOUT => Max time to receive complete client request headers (all protocols)
    
    # Connection settings
    keepalive_timeout 120s;             # KEEPALIVE_TIMEOUT => Max idle time before closing client connection
    keepalive_requests 10000;           # KEEPALIVE_REQUESTS => Max requests per client connection before forced close
    http2_recv_buffer_size 128k;        # HTTP2_RECV_BUFFER_SIZE => Increased: HTTP/2 flow control window size per connection
    http2_chunk_size 8k;                # HTTP2_CHUNK_SIZE => optimal chunk size

    # ============================================
    # UPSTREAM (HTTP/2 to NestJS)
    # ============================================
    upstream nestjs_api {
        server 127.0.0.1:3001;          # UPSTREAM_API_PORT => Upstream NestJS API port
        zone nestjs_api 256k;           # UPSTREAM_ZONE_SIZE => Increased zone: Shared memory for worker coordination
        keepalive 512;                  # UPSTREAM_KEEPALIVE_MAX => Increased: Max idle upstream connections cached per worker
        keepalive_timeout 300s;         # UPSTREAM_KEEPALIVE_TIMEOUT => Max idle time for cached upstream connections
        keepalive_requests 20000;       # UPSTREAM_KEEPALIVE_REQUESTS => Increased: Max requests per upstream connection
    }

    upstream nestjs_webhook {
        server 127.0.0.1:3003;          # UPSTREAM_WEBHOOK_PORT => Upstream NestJS webhook port
        zone nestjs_webhook 256k;       # UPSTREAM_ZONE_SIZE => Increased zone: Shared memory for worker coordination
        keepalive 256;                  # UPSTREAM_KEEPALIVE_MED => Increased: Max idle upstream connections cached per worker
        keepalive_timeout 300s;         # UPSTREAM_KEEPALIVE_TIMEOUT => Max idle time for cached upstream connections
        keepalive_requests 20000;       # UPSTREAM_KEEPALIVE_REQUESTS => Increased: Max requests per upstream connection
    }

    # gRPC Upstream (for internal gRPC server)
    upstream nestjs_grpc {
        server 127.0.0.1:50051;         # UPSTREAM_GRPC_PORT => Upstream NestJS gRPC port
        zone nestjs_grpc 256k;          # UPSTREAM_ZONE_SIZE => Increased zone
        keepalive 128;                   # UPSTREAM_KEEPALIVE_MIN => Increased: Keepalive connections
        keepalive_timeout 300s;         # UPSTREAM_KEEPALIVE_TIMEOUT
        keepalive_requests 20000;       # UPSTREAM_KEEPALIVE_REQUESTS => Increased
    }
    
    # Gzip compression
    gzip on;                    # Enable gzip compression for responses
    gzip_vary on;               # Add 'Vary: Accept-Encoding' header for cache proxies
    gzip_comp_level 6;          # GZIP_COMP_LEVEL => Compression level (1-9): 6 balances CPU usage vs compression ratio
    gzip_min_length 1024;       # GZIP_MIN_LENGTH => Only compress responses larger than 1KB
    gzip_proxied any;           # Compress all proxied responses regardless of headers
    gzip_disable "msie6";       # Disable gzip for old IE6 browsers due to known issues
    gzip_types                  # MIME types eligible for compression (text/html always included)
        text/plain 
        text/css 
        text/xml
        text/javascript
        application/json 
        application/javascript 
        application/xml+rss 
        application/atom+xml
        image/svg+xml;

    # ============================================
    # LOGGING
    # ============================================
    log_format security '$remote_addr - $host - $request - $status - $body_bytes_sent - '
                        '$request_time - $upstream_response_time - '
                        '"$http_user_agent" - "$http_referer" - '
                        'blocked: $blocked_reason';
    access_log /var/lib/nginx/logs/access.log security buffer=64k flush=5s;  # ACCESS_LOG_BUFFER => Increased buffer
    error_log /var/lib/nginx/logs/error.log warn;

    # Temp paths (ensure directories exist with write permissions for 'node' user)
    client_body_temp_path /var/lib/nginx/tmp/client_body;
    proxy_temp_path /var/lib/nginx/tmp/proxy;
    fastcgi_temp_path /var/lib/nginx/tmp/fastcgi;
    uwsgi_temp_path /var/lib/nginx/tmp/uwsgi;
    scgi_temp_path /var/lib/nginx/tmp/scgi;

    # Set trusted proxy IPs (CloudFlare example)
    set_real_ip_from 173.245.48.0/20;
    # ... add all CloudFlare IPs from https://www.cloudflare.com/ips/

    # Or AWS ALB private subnet
    set_real_ip_from 10.0.0.0/8;

    # real_ip_header X-Forwarded-For;
    real_ip_recursive on;

    # Request limits
    client_max_body_size 10M;           # MAX_CLIENT_BODY_SIZE => Max allowed request body size (for file uploads)
    client_body_buffer_size 512k;       # CLIENT_BODY_BUFFER_SIZE => Increased: Buffer size for reading client request body
    client_header_buffer_size 2k;       # CLIENT_HEADER_BUFFER_SIZE => Initial buffer for request headers (before large_client_header_buffers)
    
    # Timeouts
    client_body_timeout 30s;          # CLIENT_BODY_TIMEOUT => Max time between successive client body reads
    send_timeout 30s;                 # SEND_TIMEOUT => Max time between successive writes to client
    reset_timedout_connection on;     # Immediately close timed-out connections (frees resources)

    # Performance
    sendfile on;                     # Use kernel sendfile() for efficient file transfers
    tcp_nopush on;                   # Send headers + file start in one packet (with sendfile)
    tcp_nodelay on;                  # Disable Nagle's algorithm for low-latency responses
    server_tokens off;               # Hide NGINX version in error pages and headers

    # NGINX open file cache (reduces syscalls for frequently accessed files)
    open_file_cache max=100000 inactive=120s;         # OPEN_FILE_CACHE_MAX & INACTIVE => Increased: Cache up to 100k file descriptors
    open_file_cache_valid 120s;                      # OPEN_FILE_CACHE_VALID => Revalidate cached entries every 120s
    open_file_cache_min_uses 2;                     # OPEN_FILE_CACHE_MIN_USES => File must be accessed 2+ times to be cached
    open_file_cache_errors on;                      # Also cache file-not-found errors

    # ============================================
    # RATE LIMITING (geo map defines client key)
    # ============================================
    # TEST MODE
    map $http_x_forwarded_for $extracted_xff_ip {
        default $http_x_forwarded_for;
        "~^([0-9a-f\.:]+),.*$" $1;  # Get leftmost IP
    }
    # TEST MODE
    map $http_x_forwarded_for $ip_test_final {
        default $remote_addr;
        "~.+" $extracted_xff_ip;  # Use XFF if present
    }

    map $ip_test_final $limit_key {
        # default $remote_addr;
        default $ip_test_final;
    }

    # ============================================
    # DDOS PROTECTION - CONNECTION LIMITS
    # ============================================
    limit_conn_zone $limit_key zone=conn_per_ip:100m;      # LIMIT_CONN_ZONE_SIZE => Increased zone: Per-IP connection tracking
    # limit_conn_zone $server_name zone=conn_per_server:100m;         # LIMIT_CONN_ZONE_SIZE => Increased zone: Per-server connection tracking
    
    # SIGNIFICANTLY INCREASED LIMITS - Application handles granular rate limiting
    limit_req_zone $limit_key zone=api_limit:30m rate=200r/m;              # LIMIT_REQ_API_RATE => Increased: 200 req/min per IP
    limit_req_zone $limit_key zone=auth_limit:30m rate=10r/m;              # LIMIT_REQ_AUTH_RATE => Increased: 10 req/min for auth endpoints
    limit_req_zone $limit_key zone=webhook_limit:30m rate=200r/m;          # LIMIT_REQ_WEBHOOK_RATE => Increased: 200 req/min for webhooks
    limit_req_zone $limit_key zone=socketio_limit:30m rate=500r/m;         # LIMIT_REQ_SOCKETIO_RATE => Increased: 500 req/min for Socket.IO handshakes
    limit_req_zone $limit_key zone=flood_protection:30m rate=200r/s;        # LIMIT_REQ_FLOOD_RATE => Increased: 200 req/sec global anti-flood

    limit_conn_zone $limit_key zone=conn_limit:100m;                         # LIMIT_CONN_ZONE_SIZE => Zone for tracking concurrent connections per key

    # Request status tracking for 444 responses (connection drop)
    limit_req_status 444;
    limit_conn_status 444;

    # ============================================
    # SECURITY MAPS - ADVANCED THREAT DETECTION
    # ============================================
    # 1. Block invalid HTTP methods
    map $request_method $bad_method {
        default 1;
        GET 0;
        POST 0;
        PUT 0;
        PATCH 0;
        DELETE 0;
        OPTIONS 0;
        HEAD 0;
        CONNECT 0;
    }

    # 2. Detect malicious patterns in URI
    map $request_uri $is_malicious_uri {
        default 0;
        # Path traversal
        "~*(\.\./|\.\.\\\\|\.\.%2f|\.\.%5c)" 1;
        # SQL Injection
        "~*(union.*select|concat.*\(|information_schema|drop.*table)" 1;
        # XSS
        "~*(<script|javascript:|onerror=|onload=|<iframe)" 1;
        # Code injection
        "~*(eval\(|base64_decode|exec\(|system\()" 1;
        # File system access
        "~*(/proc/|/etc/passwd|/etc/shadow|/var/log)" 1;
        # Command injection
        "~*(cmd=|exec=|query=|;|\\|\\||&&|`|\\$\\()" 1;
        # Template injection
        "~*(\${|%00|phpinfo)" 1;
        # File upload exploits
        "~*(\.php|\.asp|\.aspx|\.jsp|\.cgi)$" 1;
    }

    # 3. Detect malicious patterns in query string
    map $query_string $is_malicious_query {
        default 0;
        "~*(union.*select|concat.*\()" 1;
        "~*(<script|javascript:)" 1;
        "~*(eval\(|base64_decode)" 1;
        "~*(\.\./|\.\.\\\\)" 1;
    }

    # 4. Block bad bots and scanners
    map $http_user_agent $bad_bot {
        default 0;
        # Security scanners
        "~*(nmap|nikto|sqlmap|masscan|acunetix|nessus|openvas)" 1;
        # Automated tools
        "~*(libwww-perl|python-requests|java/|winhttp|go-http-client)" 1;
        # Scrapers
        "~*(scrapy|selenium|phantomjs|headless)" 1;
        # Empty or suspicious
        "" 1;
        "-" 1;
        "~*^$" 1;
    }

    # 5. Detect suspicious referrers
    map $http_referer $bad_referer {
        default 0;
        "~*(poker|casino|viagra|cialis|pharmacy)" 1;
        "~*(sex|porn|adult)" 1;
    }

    # 6. WebSocket detection
    map $http_upgrade $is_websocket {
        default 0;
        "websocket" 1;
    }

    # 7. Block bad bots EXCEPT WebSocket upgrades
    map "$bad_bot:$is_websocket" $block_bad_bot {
        default 0;
        "1:0" 1;
    }

    # 8. Connection header for proxying
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    # 9. Validate Content-Type for POST/PUT/PATCH
    map "$request_method:$content_type" $invalid_content_type {
        default 0;
        # Allow only valid API Content-Types
        "~*^(POST|PUT|PATCH):application/json" 0;
        "~*^(POST|PUT|PATCH):multipart/form-data" 0;
        "~*^(POST|PUT|PATCH):application/x-www-form-urlencoded" 0;
        # Block everything else for POST/PUT/PATCH
        "~*^(POST|PUT|PATCH):" 1;
    }

    # 10. Block requests with null bytes
    map $request_uri $has_null_byte {
        default 0;
        "~*%00" 1;
    }

    # 11. Detect suspicious header combinations
    map $http_x_forwarded_for $suspicious_xff {
        default 0;
        "~*(\.\./|union|select|script)" 1;
    }

    # 12. Rate limit bypass detection (multiple IPs in X-Forwarded-For)
    map $http_x_forwarded_for $xff_count {
        default 0;
        "~*,.*,.*,.*," 1;  # More than 4 IPs in chain (suspicious)
    }

    # 13. Validate Accept header
    map $http_accept $invalid_accept {
        default 0;
        # Allow valid API Accept headers
        "~*application/json" 0;
        "~*\*/\*" 0;  # Allow Accept: */*
        # Block browser-like Accept headers (HTML requests)
        # "~*text/html" 1;
        "~*application/xhtml" 1;
    }

    # 14. Detect missing required headers for API requests
    map "$request_method:$http_accept:$content_type" $missing_api_headers {
        default 0;
        # POST/PUT/PATCH without Content-Type
        "~*^(POST|PUT|PATCH):.*:$" 1;
        # Any request accepting HTML (likely browser, not API client)
        "~*:.*text/html.*:" 1;
    }

    # 15. Block requests with suspicious Host header
    map $http_host $invalid_host {
        default 0;
        # Block IP-based access if you use a domain
        # "~*^\d+\.\d+\.\d+\.\d+" 1;  # Uncomment to block direct IP access
        # Block common malicious hosts
        "~*(localhost\.localdomain|example\.com)" 1;
    }

    # 16. Detect large Content-Length (>= 10,485,760 bytes, i.e., 10M)
    map $content_length $oversized_payload {
        default 0;
        # Match any Content-Length >= 10,000,000 (8+ digits, non-zero first digit)
        "~^[1-9][0-9]{7,}$" 1;
    }

    # 17. Detect sensitive keywords in query string
    map $query_string $has_sensitive_in_query {
        default 0;
        "~*(^|&)(password|passwd|pass|token|access_token|api_key|apikey|secret|client_secret|auth|session|jwt)=" 1;
        "~*(bearer%20|bearer%20token|bearer )" 1;
    }

    # 18. Detect too many query parameters (>= 50 params)
    map $args $too_many_params {
        default 0;
        "~*(?:[^&]*&){49,}" 1;
    }

    # 19. Trusted networks (no security checks)
    geo $always_allow {
        default 0;
        127.0.0.1 1;
        10.0.0.0/8 1;
    }

    # ============================================
    # COMBINED SECURITY DECISION (Single Source of Truth)
    # ============================================
    map "$always_allow:$bad_method:$is_malicious_uri:$is_malicious_query:$block_bad_bot:$bad_referer:$invalid_content_type:$has_null_byte:$suspicious_xff:$xff_count:$invalid_accept:$missing_api_headers:$oversized_payload:$has_sensitive_in_query:$too_many_params" $security_check {
        default "block:unknown";
        
        # If always_allow=1, never block
        "~^1:" "allow:trusted_network";
        
        # Check each security rule in order (first match wins)
        "~^0:1:" "block:bad_method";
        "~^0:0:1:" "block:malicious_uri";
        "~^0:0:0:1:" "block:malicious_query";
        "~^0:0:0:0:1:" "block:bad_bot";
        "~^0:0:0:0:0:1:" "block:bad_referer";
        "~^0:0:0:0:0:0:1:" "block:invalid_content_type";
        "~^0:0:0:0:0:0:0:1" "block:null_byte";
        "~^0:0:0:0:0:0:0:0:1" "block:suspicious_xff";
        "~^0:0:0:0:0:0:0:0:0:1" "block:xff_count";
        "~^0:0:0:0:0:0:0:0:0:0:1" "block:invalid_accept";
        "~^0:0:0:0:0:0:0:0:0:0:0:1" "block:missing_api_headers";
        "~^0:0:0:0:0:0:0:0:0:0:0:0:1" "block:oversized_payload";
        "~^0:0:0:0:0:0:0:0:0:0:0:0:0:1" "block:has_sensitive_in_query";
        "~^0:0:0:0:0:0:0:0:0:0:0:0:0:0:1" "block:too_many_params";
        
        # If all checks pass (all zeros after always_allow)
        "~^0:0:0:0:0:0:0:0:0:0:0:0:0:0:0$" "allow:passed";
    }

    # Extract decision (block/allow) from $security_check
    map $security_check $should_block {
        default 0;
        "~^block:" 1;
    }

    # Extract reason from $security_check
    map $security_check $blocked_reason {
        default "none";
        "~^block:(.+)$" $1;
        "~^allow:" "none";
    }

    # ============================================
    # HTTP SERVER (HTTP/2 Frontend + Backend)
    # ============================================
    server {
        listen 3000 reuseport;    # LISTEN_PORT => Port to accept client connections
        listen [::]:3000 reuseport;    # LISTEN_PORT => Port to accept client connections (IPv6)
        server_name localhost;
        http2 on;

        # ============================================
        # GLOBAL SECURITY CHECKS
        # ============================================
        
        # Block malicious requests immediately (before any processing)
        access_log /var/lib/nginx/logs/blocked.log security if=$should_block;

        if ($should_block = 1) {
            return 444;
        }
        
        # Per-IP connection limit (DDoS protection) - Increased to match host capacity
        limit_conn conn_per_ip 50;  # LIMIT_CONN_PER_IP => Increased: Max 50 concurrent connections per IP

        # Global flood protection
        limit_req zone=flood_protection burst=2000 nodelay;  # LIMIT_REQ_FLOOD_BURST => Increased burst capacity (2000)


        # ============================================
        # SECURITY HEADERS (Backend API - Minimal)
        # ============================================
        add_header X-Content-Type-Options "nosniff" always;
        # Uncomment if using HTTPS
        # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
        
        # FOR BROWSER-BASED APPS, consider enabling these headers:
        # add_header X-Frame-Options "DENY" always;
        # add_header X-XSS-Protection "1; mode=block" always;
        # add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        # add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;


        # ============================================
        # BLOCK NON-API REQUESTS (Strict API-Only Enforcement)
        # ============================================
        
        # Block requests trying to access static files
        location ~ \.(html|htm|css|js|jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf|eot|pdf|zip|tar|gz)$ {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # Block root path
        location = / {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # Block common non-API paths
        location = /favicon.ico {
            access_log off;
            return 444;
        }

        location = /robots.txt {
            access_log off;
            return 444;
        }

        # Block ALL common scanner/framework paths
        location ~ ^/(admin|phpmyadmin|wp-admin|wp-login|wp-content|wp-includes|xmlrpc\.php|\.git|\.svn|\.env|\.well-known|\.htaccess|\.user\.ini|config|backup|db|database|sql|myadmin|pma|cpanel|plesk|webmail|roundcube|shell|console|install|setup|upgrade|test|demo|staging|dev) {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # Block dangerous file extensions
        location ~ \.(asp|aspx|php|php3|php4|php5|phtml|jsp|jspx|cgi|pl|py|rb|sh|bat|exe|dll|so|bin)$ {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # Block hidden files and directories
        location ~ /\. {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # Block backup and config files
        location ~ \.(bak|backup|old|tmp|temp|log|conf|config|ini|yaml|yml)$ {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }

        # ============================================
        # SOCKET.IO (WebSocket - requires HTTP/1.1)
        # ============================================
        location /socket.io/ {
            # Rate limiting - SIGNIFICANTLY INCREASED
            limit_req zone=socketio_limit burst=5000 nodelay;  # LIMIT_REQ_SOCKETIO_BURST => Increased burst (5000)
            limit_conn conn_per_ip 2000;  # LIMIT_CONN_SOCKETIO_PER_IP => Increased: Max 2000 concurrent WebSocket connections per IP
            
            proxy_pass http://nestjs_api;
            proxy_http_version 1.1;  # HTTP/1.1 required for WebSocket Upgrade
            
            # WebSocket upgrade headers
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $limit_key;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeouts
            proxy_connect_timeout 60s;         # PROXY_CONNECT_TIMEOUT => Connection timeout for upstream
            proxy_send_timeout 300s;           # PROXY_SEND_TIMEOUT_SOCKETIO => Send timeout for socket.io upstream
            proxy_read_timeout 300s;           # PROXY_READ_TIMEOUT_SOCKETIO => Read timeout for socket.io upstream
            
            # Disable buffering
            proxy_buffering off;
            proxy_cache off;
            proxy_request_buffering off;
            proxy_redirect off;
            proxy_set_header x-request-timestamp $msec;
        }
        
        # ============================================
        # WEBHOOK ENDPOINT (HTTP/2)
        # ============================================
        location /webhook/ {
            limit_req zone=webhook_limit burst=500 nodelay;  # LIMIT_REQ_WEBHOOK_BURST => Increased burst (500)
            limit_conn conn_per_ip 2000;  # LIMIT_CONN_WEBHOOK_PER_IP => Increased: Max 2000 concurrent connections
            
            proxy_pass http://nestjs_webhook;
            proxy_http_version 1.1;  # HTTP/1.1 for upstream keepalive
            
            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $limit_key;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Connection "";
            
            # Timeouts
            proxy_connect_timeout 60s;   # PROXY_CONNECT_TIMEOUT_WEBHOOK => Connection timeout for webhook upstream
            proxy_send_timeout 60s;      # PROXY_SEND_TIMEOUT_WEBHOOK => Send timeout for webhook upstream
            proxy_read_timeout 60s;      # PROXY_READ_TIMEOUT_WEBHOOK => Read timeout for webhook upstream
            proxy_buffering off;
            proxy_set_header x-request-timestamp $msec;
        }
        
        # ============================================
        # AUTH ENDPOINTS (moderate rate limits)
        # ============================================
        location ~ ^/api/v1/(auth|login|register|password-reset) {
            limit_req zone=auth_limit burst=200 nodelay;  # LIMIT_REQ_AUTH_BURST => Increased: 200 burst
            limit_conn conn_limit 100;  # LIMIT_CONN_AUTH => Increased: Max 100 concurrent connections per key
            
            proxy_pass http://nestjs_api;
            proxy_http_version 1.1;  # HTTP/1.1 for upstream keepalive
            
            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $limit_key;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Connection "";
            
            # Timeouts
            proxy_connect_timeout 30s;   # PROXY_CONNECT_TIMEOUT_AUTH => Connection timeout for auth upstream
            proxy_send_timeout 30s;      # PROXY_SEND_TIMEOUT_AUTH => Send timeout for auth upstream
            proxy_read_timeout 30s;      # PROXY_READ_TIMEOUT_AUTH => Read timeout for auth upstream
            proxy_set_header x-request-timestamp $msec;
        }

        # ============================================
        # GENERAL API (HTTP/2)
        # ============================================
        location ~ ^/api/ {
            limit_req zone=api_limit burst=5000 nodelay;  # Increased burst
            limit_conn conn_per_ip 500;  # Increased: Max 500 concurrent API requests per IP
            
            proxy_pass http://nestjs_api;
            proxy_http_version 1.1;  # HTTP/1.1 for upstream keepalive
            
            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $limit_key;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Connection "";
            
            # Timeouts
            proxy_connect_timeout 60s;   # PROXY_CONNECT_TIMEOUT_API => Connection timeout for API upstream
            proxy_send_timeout 60s;      # PROXY_SEND_TIMEOUT_API => Send timeout for API upstream
            proxy_read_timeout 60s;      # PROXY_READ_TIMEOUT_API => Read timeout for API upstream

            # Buffer settings
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;
            proxy_set_header x-request-timestamp $msec;
        }

        # ============================================
        # gRPC proxy
        # ============================================
        location ~ ^/grpc/ {
            grpc_pass grpc://nestjs_grpc;

            # Timeouts
            proxy_connect_timeout 120s;   # PROXY_CONNECT_TIMEOUT_GRPC => Connection timeout for gRPC upstream
            proxy_send_timeout 300s;      # PROXY_SEND_TIMEOUT_GRPC => Send timeout for gRPC upstream
            proxy_read_timeout 300s;      # PROXY_READ_TIMEOUT_GRPC => Read timeout for gRPC upstream

            # Headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $limit_key;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Disable buffering for streaming
            proxy_buffering off;
            proxy_cache off;
            proxy_request_buffering off;
            proxy_set_header x-request-timestamp $msec;
        }
        
        # ============================================
        # BLOCK EVERYTHING ELSE
        # ============================================
        location / {
            access_log /var/lib/nginx/logs/blocked.log security;
            return 444;
        }
    }
}